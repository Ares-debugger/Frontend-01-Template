# 每周总结可以写在这里
【动态规划】
	其实是动态递推，也就是说Programming的意思更多的是“递推”而不是规划。指的是将一个复杂问题转化为简单的子问题，因此动态规划必须进行分治。只不过，这个分治的组合方式，是以递归形式进行的，这个就跟一般的分治不一样了。
	一般来说，动态规划是一种“优化算法”，要求解一个最大值，最优解这样的。动态规划存在一个“最优子结构”的问题，正是因为每一步都是最优子结构，因此中间不需要保存结果。只需要存最优的状态（中途可以淘汰掉次优解）。
	※动规、递归、分治、回溯没有本质上的区别；
	※关键问题在于有没有最优子结构，如果没有的话，说明每个子问题都要做一遍。
		没有比较和淘汰的过程，就是分治（认为最优解就是当前解）
		每次都有比较和淘汰的过程，就是动态规划（每次找一个最优解）
案例1：斐波那契数列
		（1）记忆化缓存
		加缓存怎么加呢？加一个数组：
		if n <= 1:return n;
		if memo[n] == 0: 
# 没有被计算过，只能从头创业,已经被计算过了那就会跳过
# 通过if的方式，可以砍掉节点
			memo[n] = fib(n-1)+fib(n-2)
		return memo[n]
		（2）自底向上（dp方法）
		人脑的思维习惯是自顶向下，但是实际上还能够递推
		初始值有了，一个个的进行递推，采用3个值滑窗进行，变量更新。
	注意：如果追求dp功力深厚，所有的竞赛选手，都是自底向上循环开始写递归的。
案例2：不同路径I、II
		从一维到二维。如何找重复性？实际上是一种大量的状态树。
 
我只有可能走到B和A两个位置，那么从起点走到终点，就转成了2个子问题，从B走到终点的解数量+从A走到终点的解数量。那么对于每一步，都是从下面走到终点的解数量+从右边走到终点的解数量。实际上，就是DP的状态转移方程。以optimal作为解的数量。可以得出：
if a[i,j]==’空地’：optimal[I,j] = optimal[i+I,j]+optimal[I,j+1]
else: optimal[I,j]=0 # 表示这个点上没有解，迭代到其他位置也是这样（加0）
【状态转移方程】
		状态转移方程，说白了，就是解的分解。例如前面的状态转移方程就是：
if 空地：optimal[I,j] = optimal[i+I,j]+optimal[I,j+1]
else: optimal[I,j]=0
		用DP递推的方式怎么写呢？
		实际上换一种思路，你可以知道从终点怎么往前走。
	实际上是一个初始值嘛，递推终点走到所有格子的数量。实际上状态转移方程就变成：通过右边和下面的计算左上角的格子。
 
实际上，最后的27=10+17，我只要相信10和17都是对的，那么27就是对的，同理，我只要相信12和5是对的，那么17就是对的。。。最后我只要相信1+1=2是对的，那么数学归纳法思维，就全部写出来了。
代码实现：首先是获取初值，把最下面一行和最右边一列全部赋值为1，然后开始递推了。简化的思路就是和fib一样，我们只需要存当前这一行往上面垒，不断更新即可。自己累加j-1的值即可。
【动态规划关键点】
 
第一步：分治：最优子结构：这里实际上就是中间过程的累加，都要是最优的；这里是路径问题，以后还可能有最小值啊最大值这些的；
第二步：必须定义中间状态且储存中间状态。分治的话可能就不管这一步，但是DP需要专门开一个数组来存状态。
第三步：DP方程就是递推公式，不同问题的DP方程式不一样的。fib的递推是很简单的，二维路径规划的方程除了递推，还有判断空地。
		对于初学者和面试来说，最难的是第二步，对于高手来说，最难的是第三步。只要把状态定义出来且把状态定义对了，差不多就可以解出来。
案例3：1143最长公共子序列
	前面是1维数组dp，然后是二维数组dp，下面是字符串来变化进行dp。为什么字符串会不一样呢，因为涉及到字符串的话就不是简单的dp了，而是一个二维数组来定义状态。前面两个状态空间都不需要自己创建。
	非常精妙的采用二维矩阵的方式，模拟路径规划，构造状态方程。
	最长公共子序列。首先就是暴力，暴力就是枚举，枚举所有子序列看看是不是在第二个里面。因此可以用排列组合。对于text1中的每一个字母都是取或者不取，生成了所有的子序列。如果这个子序列在text2里面存在，也就是一个个字母比过去，可以有间隔，但是顺序必须一致。所谓的排列组合其实就是递归求解即可。
	找重复性并且化简为斐波那契数据的形式；第一个经验就是从后面开始往前面看，比如说，第一个字符串是……A,第二个是…A，这个时候A就肯定是一个相同的了，实际上这里就转化成了一个子问题。第二个经验是构建二维矩阵。二维矩阵当中的每一个坐标值[I,j]，指的是第一个字符串的[:i]和第二个字符串的[:j]这两个子串的最长公共子序列的长度。
 
	那么开始递推的话，第一行和第一列，可以计算的。实际上问题完全化简为了一个字符和另一个字符串之间的关系，这个时候是比较简单，一眼就能看出来的。
	第一行和第一列初始化好了之后，就可以进行递推了。
	假如说最后一个字符都相同的话，那答案就是前缀的子问题+1；
	否则，第一个……A,第二个是…A，要么是……和A要么是…和A字符再减一。例如，如何计算AB和BA之间的子序列：也就是[1,1]那个位置，我们可以看到，要么就是B和AB之间的最长公共子序列，要么就是A和BA之间的最长公共子序列。看右边那个3怎么来的，实际上求的是ABAZDC和BAC之间的最长公共子序列。 这个时候我们发现最后一个字母相同，那么转化为只需要求ABAZD和BA之间的最长序列+1。这个时候状态方程可以写为：
	if s1[-1]!=s2[-1]:
		LCS[S1,S2]=Max(LCS[s1-1,s2],LCS[s1,s2-1])
		# s1去掉一个字符和s2来比，或者是s2去掉一个字符和s1来比
			他们的最长公共子序列，从中选一个较大者过来；
	if s1[-1]==s2[-1]:
		LCS[s1,s2]=LCS[s1-1,s2-1]+1
【思维小结】
	1、打破思维惯性，形成机器思维——找重复性；
	2、理解复杂逻辑的关键——秒变傻瓜。
案例4：三角形最小路径和
		走下一层相邻的两个节点。
		暴力法递归：每一层可以左或者右，O2n
	DP:找到重复性，定义状态数组，列出DP方程。从上往下的方式，就是递归分治。为什么呢，因为这种层级、树状的问题，从2往下走的最小路径和，就等于从3或者4往下走的最小路径和（较小者）加2.
problem(I,j) = min(sub(i+1,j),sub(I,j+1))+a[I,j]
