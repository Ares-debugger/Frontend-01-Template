# 每周总结可以写在这里
递归适用于子结构也具备“相似性”也就是整体具备“自相似性”的情况。
	递归本质上就是循环，只不过是使用循环体不断的调用自己完成循环。计算机底层其实是不支持循环而是支持递归的，这是因为他只会不断的跳转到函数体去实现。
	递归Recursion 从前有座山……《盗梦空间》
【递归的特点】
（1）一层一层的下，一层一层的回来；
（2）通过函数的参数完成不同层之间的状态传递；
（3）每一层的环境和其他的都是一份拷贝，互不影响
递归的运算，一层的话是递归栈（剥洋葱），两层的话是递归树：
 
在调用递归的时候，系统会自动给我们做出来一个调用栈。
【递归代码模板】
def recursion(level,param1,param2……):
	# resursion terminator
if level > MAX_LEVEL:
		return process_result
	
	# process logic in current level
	process(level,data……)

	# drill down
	self.recursion(level+1,p1….)
	
	# reverse the current level status if needed
第一步：先把递归终止条件写出来。
第二步：处理当前层的逻辑（实际上是参数之间的运算）
第三步：下到下一层，把level+1，把参数放到下一层（其实是前面改变的）
第四步：如果有清理当前层的话，就清理，环境和全局变量可能需要清理
下面是最关键的，设计的时候，通常需要把中间变量参数和结果变量参数一起传到递归函数里面去。例如，设计一个cur和一个res，每一层保持把cur清零即可。
【递归思维要点】
	（1）熟练后抵制进行人肉递归与人肉尝试算法（因为本身很简单）
	（2）找到最近最简的方法，将其拆解成可重复解决的问题（最近重复子问题）
	（3）数学归纳法思维，最简单的条件是成立
与其这样说，不如说是：每次对“状态树”的下一层节点施加递归。递归函数中的参数，应该是“状态参数”。
组合、排列、N皇后等问题，本质上都是树状的搜索空间，因此都可以采用递归的方法求解。
【递归实战解析】
		案例1爬楼梯问题：假设有n级台阶，你每次可以上1或者2级，
这里面，一定要找到“重复性”，重复性往往存在与相邻两次的结果中：
		为什么说递归难？因为递归是基于结果而不是基于已知的。
		这里比较厉害了，递归的终止条件是1级或者2级台阶。
		再往上我们就不要穷举了：而是把n-1的结果当成已知：
	例如，n=3的时候，有两种情况，第一种是n=1的解法往上走1+1，第二种是n=2的解法往上走一步。第三种是n=1的解法往上走2
	抽象出来，最大的重复性就出现了：
	假设结果为f(n)，f(n)=f(n-1)+1 & f(n-2)+2 & f(n-2)+1+1（这是不对的）
	f(n-2)+1+1  f(n-1)+1
	并且这里也没有漏算的情况，也没有重复的情况
	mutual exclusive complete exclusive （分项都是互斥的）
	但是这样的话也不够，不是一个通项公式啊,题目的要求并不是打印出所有的“方法”，而是打印出“有多少种”
	f(1)=1 f(2)=2 f(3)=f(1)+f(2)=3
	这是因为：f(n-1)表示我已经站上台阶了的方法，对于每一个f(n-1)方法，我是不是只需要+1就可以获取到站在f(n-1)上往f(n)走的数量；对于每一个已经站在f(n-2)上的方法，那么我只有一步跨两个台阶的方法。（有一种是重复的）
因此自然可以写出：
	f(n)=f（n-1）+f（n-2）
	斐波那契数列有几种方法：傻递归：
	def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n==1:return 1
        if n==2:return 2
        return self.climbStairs(n-1) + self.climbStairs(n-2)
	这里面，状态参数就是n，分叉出来两个状态参数n-1和n-2
	很明显，超出时间限制
	第二种：动态规划更新状态的方式，实际上整体只有三个数在动：
		f(n),f(n-1)和f(n-2)
		我只需要一个列表循环滚动过去即可,且不需要其他中间变量
		if n < 3: return n
		f1,f2,f3 = 1,2,3
for I in range(n):
			f3 = f1 + f2
			f1 = f2 # 滚动
			f2 = f3 # 滚动
		return f3 
		案例2 括号生成
	一下子把时间复杂度从O(2^n)降低到了O(n)，空间复杂度从O(n)降到了O(1)
左边括号随时可以加，但是不要超过n，右括号不能出现的情况，必须之前有左括号，且左括号个数大于右括号个数
		这个里面能够深刻理解递归。
		案例3 翻转二叉树
		案例4 二叉树的最大/最小深度
		案例5 前后序来构造二叉树
【分治和回溯】
【深度优先搜索与树状空间】
大量的问题都是树状的搜索空间，我们要找到合理的结果，就应该是从树状的搜索空间中寻找可能的结果，这个结果，就是从根节点到叶子节点的所有结果。必然要求是深度优先搜索。
【剪枝】
剪枝其实是一种非常常见的思路，在神经网络中也会有出现。说白了就是增加一些判断条件，不再去遍历这个节点往下的结果。
【基本思路】
	都是找重复性，然后合并子问题的结果。
	分治的代码模板：
	def divide_conquer(problem,param1,param2,…):
		if problem is None: # 叶子节点到达的标志在于子问题没有了
			print_result 
			return
		data = prepare_data(problem)
		subproblems = split_problem(problem,data)
		subresult1 = self.divide_conquer(subproblems[0],p1,…)
		subresult2 = self.divide_conquer(subproblems[1],p1,…)
		subresult3 = self.divide_conquer(subproblems[2],p1,…)
		result = process_result(subresult1, subresult2, subresult3…)
	这个里面，如何拆分子问题是难点，如何合并子问题也是难点，另外，如何对结果进行质量控制也是难点，另外就是做得好的话有所激励。
	回溯法：不断在某一层去尝试就可以了，通常使用最简单的递归。
	案例1：求x的n次方
		分治法：
		        if n==0:return 1
        		if n < 0:
            		x = 1/x
            		n = -n
        		if n%2:return x*self.myPow(x,n-1)
        		else:return self.myPow(x*x,n/2)
	案例2：排列组合
组合是一个典型的回溯问题。回溯是一种穷举所有可行解的办法，如果最后没有可行解的话，就会在前面修改一些条件。
 
例如，从集合里面选出两个数，那么有多少种不重复的情况？回溯的通常方式就是，一个最简单的递归形式。
现在不用管回溯的问题。组合，是不是选了一个数，剩下的状态是从剩下的数里面选？？既然是这样的话，每一层都有个起点吧，然后cur达到对应的长度之后，就会添加进来，cur和res一起传到下面一层。
	def combine(self,n,k)
res = []
        def _helper(start,n,k,cur,res):
            if len(cur)==k:
                res.append(cur[:]) # 必须是深拷贝，拷贝整体
                return None

            for i in range(start,n+1):
                cur.append(i)
                _helper(i+1,n,k,cur,res)
                cur.pop()
        _helper(1,n,k,[],res)
        return res
全排列也是一样的，那么，总共有三个格子就是三层。注意，每次用完当前元素，我就要撤销掉了，这是回溯的基本思想。
def permute(nums):
res = []
        def _dfs(nums,size,depth,cur,used,res)
            if len(cur)==size:
                res.append(cur[:])
                return None

            for i in range(size):
                if used[i] == False:
                    # 把使用状态更新，然后增加元素
                    used[i] = True
                    cur.append(nums[i])
                    # 下探
                    _def(nums,size,depth+1,cur,used,res)
                    # 撤销所有状态，完成回溯
                    used[i] = False
                    cur.pop()

        size = len(nums)
        used = [False for _ in range(size)]
        _def(nums,size,0,[],used,res)
        return res
	案例3：子集
		再回顾一下爬楼梯问题：每次上1,2，有多少种方式拿到n
		回顾一下硬币兑换问题：面值为2,5,10，有多少情况能达到100
		回顾一下排列组合问题：每一个值取还是不取，得到要的结果
		回顾一下左括号和右括号：总共有n个，来进行挑选
	子集问题：有n个格子，你取还是不取？在程序设计中，可以用乘0和1的方式实现。实际上相当于左括号或者右括号。
	根据选和不选，得到形式。层的话，就是集合中元素的个数。每一层的话，我只需要考虑当前层选还是不选，其他的通通不考虑。
	案例4：众数
	案例5：电话号码的组合（最清晰递归！）
转换成之前的问题，有9个格子，每个格子有n个字母，给定一些格子，要给出排列组合。实际上还是一样，循环枚举出下一层的所有可能情况再dirlldown，只不过这个参数的设计上，不是很好。实际上就是，树状的递归状态。每一次排列组合都会遇到这样的树状结构，最适合做递归了。
再次体现了，我只需要去考虑当前的问题，不需要去考虑所有问题的思想：
 
	每一层，我只处理当前层的问题。也就是当前这个数的问题。当前的数怎么做，肯定是要找出来他对应的那一组数字，然后带着这一组数字，交到下一层去，也就是交到下一个字典里面的数据即可。
	案例6：N皇后问题
N皇后问题堪称是避免打击的重要问题。在广泛的空间里面规避敌人可能的攻击范围。基本思路：如果queen放满了，那么，result.append(queens)
	queens 表示的是每一行皇后放在哪一个列上面。需要存储前面所有皇后攻击的区域，判断当前当前格子在不在里面。、
	国际站代码
